[{"name":"app.R","content":"library(shiny)\r\n\r\n\r\nsource(\"global.R\", local = T)\r\n\r\n\r\nsource(\"ui.R\")\r\nsource(\"server.R\")\r\n\r\n\r\n# Run the application \r\nshinyApp(ui = ui, server = server)\r\n\r\n\r\n","type":"text"},{"name":"server.R","content":"server <- function(input, output) {\r\n    output$plot_4 <- renderPlot({\r\n        df_4_s <- subset(df_4, year == input$year)\r\n        ggplot(df_4_s, aes(x = month, y = cases)) +\r\n            geom_bar(stat = \"identity\", fill = \"steelblue\") +\r\n            theme_minimal() +\r\n            labs(\r\n                title = \"Total de casos\",\r\n                x = \"Mês\",\r\n                y = \"Número de casos\"\r\n            ) +\r\n            theme(axis.text.x = element_text(angle = 45, hjust = 1))\r\n    })\r\n\r\n    output$plot_3 <- renderPlot({\r\n        df_3_s <- subset(df_3, year == input$year)\r\n\r\n        ggplot(df_3_s, aes(x = month, y = cases, fill = clinical_presentation, group = clinical_presentation)) +\r\n            geom_area() +\r\n            theme_classic() +\r\n            theme(legend.position = \"bottom\") +\r\n            labs(fill = \"Apresentação clínica\", y = \"Número de casos\", x = \"Mês\")\r\n    })\r\n\r\n    output$plot_2 <- renderPlot({\r\n        # req(input$year)\r\n        df_2_s <- subset(df_2, year == input$year)\r\n\r\n        ggplot(df_2_s, aes(x = month, y = cases, group = age_group, color = age_group)) +\r\n            geom_line(size = 2, alpha = 0.7) + # Add the line\r\n            geom_point(size = 5, alpha = 0.7) + # Add points at each data point\r\n            theme_classic() + # Use a minimal theme\r\n            labs(\r\n                x = \"Mês\",\r\n                y = \"Número de casos\",\r\n                color = \"Faixa etária\" # Change the legend title\r\n            ) +\r\n            theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\r\n            theme(legend.position = \"bottom\")\r\n    })\r\n}\r\n\r\n","type":"text"},{"name":"ui.R","content":"ui <-page_fillable(\r\n    card(\r\n        full_screen = TRUE,\r\n        layout_sidebar(\r\n            sidebar = sidebar(\r\n                selectInput(\r\n                    \"year\",\r\n                    \"Ano\",\r\n                    choices = list(\"2023\" = 2023, \"2024\" = 2024),\r\n                    selected = 1\r\n                ),\r\n                position = \"right\"\r\n            ),\r\n            plotOutput(\"plot_4\")\r\n        )\r\n    ),\r\n    layout_columns(\r\n        card(\r\n            full_screen = TRUE,\r\n            plotOutput(\"plot_2\")\r\n        ),\r\n        card(\r\n            full_screen = TRUE,\r\n            plotOutput(\"plot_3\")\r\n        )\r\n    )\r\n)","type":"text"},{"name":"global.R","content":"library(shiny)\r\nlibrary(bslib)\r\nlibrary(ggplot2)\r\n\r\nmonths_vector <- c(\r\n    \"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\",\r\n    \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"\r\n)\r\n# Create a named vector mapping month names to their respective numerical levels\r\nmonths_levels <- c(\r\n    \"Jan\" = 1, \"Fev\" = 2, \"Mar\" = 3, \"Abr\" = 4, \"Mai\" = 5,\r\n    \"Jun\" = 6, \"Jul\" = 7, \"Ago\" = 8, \"Set\" = 9, \"Out\" = 10,\r\n    \"Nov\" = 11, \"Dez\" = 12\r\n)\r\n\r\n# reading plot4\r\ndf_4 <- read.csv(\"https://raw.githubusercontent.com/gcgbarbosa/dashboard-assets-tmp/main/br_dengue_4.csv\")\r\ndf_4$month <- factor(df_4$month,\r\n    levels = names(months_levels),\r\n    labels = names(months_levels)\r\n)\r\n# df_4 <- subset(df_4, year == 2023)\r\n\r\n# reading plot3\r\ndf_3 <- read.csv(\"https://raw.githubusercontent.com/gcgbarbosa/dashboard-assets-tmp/main/br_dengue_3.csv\")\r\ndf_3$month <- factor(df_3$month,\r\n    levels = names(months_levels),\r\n    labels = names(months_levels)\r\n)\r\n# df_3 <- subset(df_3, year == 2023)\r\n\r\n# reading plot3\r\ndf_2 <- read.csv(\"https://raw.githubusercontent.com/gcgbarbosa/dashboard-assets-tmp/main/br_dengue_2.csv\")\r\ndf_2$month <- factor(df_2$month,\r\n    levels = names(months_levels),\r\n    labels = names(months_levels)\r\n)\r\n# df_2 <- subset(df_2, year == 2023)\r\n\r\n\r\n","type":"text"},{"name":"myapp/app.R","content":"library(shiny)\n\n# Define UI for app that draws a histogram ----\nui <- fluidPage(\n\n  # App title ----\n  titlePanel(\"Hello Shiny!\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      # Input: Slider for the number of bins ----\n      sliderInput(inputId = \"bins\",\n                  label = \"Number of bins:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Histogram ----\n      plotOutput(outputId = \"distPlot\")\n\n    )\n  )\n)\n\n# Define server logic required to draw a histogram ----\nserver <- function(input, output) {\n\n  # Histogram of the Old Faithful Geyser Data ----\n  # with requested number of bins\n  # This expression that generates a histogram is wrapped in a call\n  # to renderPlot to indicate that:\n  #\n  # 1. It is \"reactive\" and therefore should be automatically\n  #    re-executed when inputs (input$bins) change\n  # 2. Its output type is a plot\n  output$distPlot <- renderPlot({\n\n    x    <- faithful$waiting\n    bins <- seq(min(x), max(x), length.out = input$bins + 1)\n\n    hist(x, breaks = bins, col = \"#75AADB\", border = \"white\",\n         xlab = \"Waiting time to next eruption (in mins)\",\n         main = \"Histogram of waiting times\")\n\n    })\n\n}\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n","type":"text"},{"name":"myapp/DESCRIPTION","content":"Title: Hello Shiny!\nAuthor: RStudio, Inc.\nAuthorUrl: http://www.rstudio.com/\nLicense: MIT\nDisplayMode: Showcase\nTags: getting-started\nType: Shiny\n","type":"text"},{"name":"myapp/Readme.md","content":"This small Shiny application demonstrates Shiny's automatic UI updates. \n\nMove the *Number of bins* slider and notice how the `renderPlot` expression is automatically re-evaluated when its dependant, `input$bins`, changes, causing a histogram with a new number of bins to be rendered.\n","type":"text"}]
